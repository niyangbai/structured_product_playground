{"version":3,"file":"static/js/211.6725bc65.chunk.js","mappings":"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","sources":["simulation/simulationEngine.ts"],"sourcesContent":["import { AnyBrick, BrickConnection, MarketScenario, SimulationResult, PayoffPoint } from '../types';\n\nexport class SimulationEngine {\n  private bricks: AnyBrick[];\n  private connections: BrickConnection[];\n\n  constructor(bricks: AnyBrick[], connections: BrickConnection[]) {\n    this.bricks = bricks;\n    this.connections = connections;\n  }\n\n  async simulate(scenario: MarketScenario): Promise<SimulationResult> {\n    const { parameters } = scenario;\n    const payoffData: PayoffPoint[] = [];\n    \n    // Generate price path based on scenario\n    const pricePath = this.generatePricePath(scenario);\n    \n    let cumulativePayoff = 0;\n    let maxGain = 0;\n    let maxDrawdown = 0;\n    let profitableOutcomes = 0;\n    \n    // Simulate each time step\n    for (let i = 0; i < pricePath.length; i++) {\n      const time = (i / (pricePath.length - 1)) * parameters.timeHorizon;\n      const spotPrice = pricePath[i];\n      \n      // Calculate payoff for this time step\n      const stepPayoff = this.calculateStepPayoff(spotPrice, time, scenario);\n      cumulativePayoff += stepPayoff;\n      \n      // Track statistics\n      maxGain = Math.max(maxGain, cumulativePayoff);\n      maxDrawdown = Math.min(maxDrawdown, cumulativePayoff);\n      \n      if (cumulativePayoff > 0) {\n        profitableOutcomes++;\n      }\n      \n      payoffData.push({\n        time,\n        spotPrice,\n        payoff: stepPayoff,\n        cumulativePayoff,\n        triggerEvents: this.detectTriggerEvents(spotPrice, time),\n      });\n    }\n\n    return {\n      scenario,\n      payoffData,\n      finalPayoff: cumulativePayoff,\n      maxDrawdown,\n      maxGain,\n      probabilityOfProfit: profitableOutcomes / pricePath.length,\n    };\n  }\n\n  private generatePricePath(scenario: MarketScenario): number[] {\n    const { startPrice, endPrice, volatility, drift, timeHorizon, steps } = scenario.parameters;\n    const dt = timeHorizon / steps;\n    const path: number[] = [startPrice];\n\n    let currentPrice = startPrice;\n    \n    for (let i = 1; i <= steps; i++) {\n      // Generate random component\n      const random = this.boxMullerRandom();\n      \n      // Calculate price change based on scenario type\n      let priceChange = 0;\n      \n      switch (scenario.type) {\n        case 'uptrend':\n          priceChange = currentPrice * (drift * dt + volatility * Math.sqrt(dt) * random);\n          break;\n        case 'downtrend':\n          priceChange = currentPrice * (drift * dt + volatility * Math.sqrt(dt) * random);\n          break;\n        case 'flat':\n          priceChange = currentPrice * (volatility * Math.sqrt(dt) * random);\n          break;\n        case 'volatile':\n          priceChange = currentPrice * (drift * dt + volatility * Math.sqrt(dt) * random * 1.5);\n          break;\n        default:\n          priceChange = currentPrice * (drift * dt + volatility * Math.sqrt(dt) * random);\n      }\n      \n      currentPrice = Math.max(0.01, currentPrice + priceChange);\n      path.push(currentPrice);\n    }\n\n    // Adjust path to hit target end price if specified\n    if (endPrice !== undefined && scenario.type !== 'custom') {\n      const adjustment = endPrice / currentPrice;\n      for (let i = 1; i < path.length; i++) {\n        const factor = Math.pow(adjustment, i / (path.length - 1));\n        path[i] *= factor;\n      }\n    }\n\n    return path;\n  }\n\n  private calculateStepPayoff(spotPrice: number, time: number, scenario: MarketScenario): number {\n    // Simple payoff calculation - in a real implementation, this would\n    // evaluate the entire brick network\n    const underlyingAssets = this.bricks.filter(b => b.type === 'UnderlyingAsset');\n    const options = this.bricks.filter(b => b.category === 'option');\n    \n    let totalPayoff = 0;\n    \n    // Calculate option payoffs\n    for (const option of options) {\n      switch (option.type) {\n        case 'VanillaOption':\n          const strike = (option.properties as any).strike;\n          const isCall = (option.properties as any).optionType === 'call';\n          const isLong = (option.properties as any).position === 'long';\n          \n          let optionPayoff = isCall \n            ? Math.max(0, spotPrice - strike)\n            : Math.max(0, strike - spotPrice);\n            \n          optionPayoff *= isLong ? 1 : -1;\n          optionPayoff *= (option.properties as any).notional / 1000; // Normalize\n          \n          totalPayoff += optionPayoff;\n          break;\n          \n        case 'DigitalOption':\n          const digitalStrike = (option.properties as any).strike;\n          const payout = (option.properties as any).payoutAmount;\n          const isAbove = (option.properties as any).barrier === 'above';\n          \n          const condition = isAbove ? spotPrice >= digitalStrike : spotPrice <= digitalStrike;\n          totalPayoff += condition ? payout : 0;\n          break;\n          \n        // Add more option types as needed\n      }\n    }\n    \n    return totalPayoff;\n  }\n\n  private detectTriggerEvents(spotPrice: number, time: number): string[] {\n    const events: string[] = [];\n    \n    // Check for barrier triggers\n    const barrierTriggers = this.bricks.filter(b => b.type === 'BarrierTrigger');\n    for (const trigger of barrierTriggers) {\n      const level = (trigger.properties as any).barrierLevel;\n      const type = (trigger.properties as any).triggerType;\n      \n      if ((type === 'above' && spotPrice >= level) ||\n          (type === 'below' && spotPrice <= level) ||\n          (type === 'touch' && Math.abs(spotPrice - level) < 0.01)) {\n        events.push(`Barrier ${type} ${level} triggered`);\n      }\n    }\n    \n    // Check for autocall triggers\n    const autocallTriggers = this.bricks.filter(b => b.type === 'AutocallTrigger');\n    for (const trigger of autocallTriggers) {\n      const level = (trigger.properties as any).autocallLevel;\n      if (spotPrice >= level) {\n        events.push(`Autocall at ${level} triggered`);\n      }\n    }\n    \n    return events;\n  }\n\n  private boxMullerRandom(): number {\n    // Box-Muller transformation for normal distribution\n    const u1 = Math.random();\n    const u2 = Math.random();\n    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n  }\n}"],"names":["SimulationEngine","constructor","bricks","connections","this","simulate","scenario","parameters","payoffData","pricePath","generatePricePath","cumulativePayoff","maxGain","maxDrawdown","profitableOutcomes","i","length","time","timeHorizon","spotPrice","stepPayoff","calculateStepPayoff","Math","max","min","push","payoff","triggerEvents","detectTriggerEvents","finalPayoff","probabilityOfProfit","startPrice","endPrice","volatility","drift","steps","dt","path","currentPrice","random","boxMullerRandom","priceChange","type","sqrt","undefined","adjustment","factor","pow","filter","b","options","category","totalPayoff","option","strike","properties","isCall","optionType","isLong","position","optionPayoff","notional","digitalStrike","payout","payoutAmount","barrier","events","barrierTriggers","trigger","level","barrierLevel","triggerType","abs","autocallTriggers","autocallLevel","u1","u2","log","cos","PI"],"sourceRoot":""}